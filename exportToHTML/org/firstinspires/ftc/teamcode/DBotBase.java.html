<html>
<head>
<title>DBotBase.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: #999999; font-weight: normal; font-style: normal; }
.s0 { color: rgb(0,0,128); font-weight: bold; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,128,0); font-weight: bold; }
.s3 { color: rgb(128,128,128); font-style: italic; }
.s4 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
DBotBase.java</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">org.firstinspires.ftc.teamcode; 
 
</span><span class="s0">import </span><span class="s1">com.qualcomm.robotcore.eventloop.opmode.LinearOpMode; 
</span><span class="s0">import </span><span class="s1">com.qualcomm.robotcore.hardware.DcMotor; 
</span><span class="s0">import </span><span class="s1">com.qualcomm.robotcore.util.ElapsedTime; 
</span><span class="s0">import </span><span class="s1">com.qualcomm.robotcore.util.Range; 
 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.ClassFactory; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.AngleUnit; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.AxesOrder; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.AxesReference; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.Orientation; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.tfod.Recognition; 
</span><span class="s0">import </span><span class="s1">org.firstinspires.ftc.robotcore.external.tfod.TFObjectDetector; 
 
</span><span class="s0">import </span><span class="s1">java.util.ArrayList; 
</span><span class="s0">import </span><span class="s1">java.util.List; 
 
 
</span><span class="s0">public abstract class </span><span class="s1">DBotBase </span><span class="s0">extends </span><span class="s1">LinearOpMode { 
 
    </span><span class="s0">private static final </span><span class="s1">String TFOD_MODEL_ASSET = </span><span class="s2">&quot;RoverRuckus.tflite&quot;</span><span class="s1">; 
    </span><span class="s0">private static final </span><span class="s1">String LABEL_GOLD_MINERAL = </span><span class="s2">&quot;Gold Mineral&quot;</span><span class="s1">; 
    </span><span class="s0">private static final </span><span class="s1">String LABEL_SILVER_MINERAL = </span><span class="s2">&quot;Silver Mineral&quot;</span><span class="s1">; 
    </span><span class="s0">static final </span><span class="s1">String VUFORIA_KEY = </span><span class="s2">&quot;AVVrDYb/////AAABmT0TlZXDYE3gpf/zMjQrOgACsYT0LcTPCkhjAmq0XO3HT0RdGx2eP+Lwumhftz4e/g28CBGg1HmaFfy5kW9ioO4UGDeokDyxRfqWjNQwKG3BanmjCXxMxACaJ7iom5J3o4ylWNmuiyxsK8n1fFf2dVsTUsvUI7aRxqTahnIqqRJRsGmxld18eHy/ZhHfIjOyifi4svZUQiput21/jAloTx0sTnnrpR1Y/xGOz+68sGuXIgLZHpAQSoZnXiczGKdahGXOg3n6dXlQPIiASE1kHp253CTwO40l1HHN083m4wYjP4FCl/9TH3tb0Wj/Ccmlhfz2omhnZQKOBe7RsIxRk+PuEGkIe5hCs/lV9+yf9iBm&quot;</span><span class="s1">; 
    </span><span class="s0">private </span><span class="s1">VuforiaLocalizer vuforia; 
    </span><span class="s0">private </span><span class="s1">TFObjectDetector tfod; 
 
    </span><span class="s3">/* Declare OpMode members. */</span><span class="s1"> 
    DBotAutoHWMap robot = </span><span class="s0">new </span><span class="s1">DBotAutoHWMap(); 
    ElapsedTime runtime = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
    </span><span class="s3">//Orientation angles;</span><span class="s1"> 
    </span><span class="s0">public </span><span class="s1">Orientation orientation; 
    </span><span class="s3">//Create the angle tracker</span><span class="s1"> 
    </span><span class="s0">public double </span><span class="s1">angle = </span><span class="s4">0</span><span class="s1">; 
    </span><span class="s0">private double </span><span class="s1">current_heading; 
 
    </span><span class="s3">//amount of clicks per cm</span><span class="s1"> 
    </span><span class="s3">//public final double ENCDISTANCE = 34.5781466113;</span><span class="s1"> 
 
    </span><span class="s0">private double </span><span class="s1">wheel_diameter = </span><span class="s4">3.937</span><span class="s1">;      </span><span class="s3">//size of wheels original 3.75</span><span class="s1"> 
    </span><span class="s0">public double </span><span class="s1">ticks_per_inch = </span><span class="s4">36.9</span><span class="s1">;</span><span class="s3">//37.4; //39.68; //35.4;      //wheel_encoder_ticks / (wheel_diameter * Math.PI);</span><span class="s1"> 
    </span><span class="s3">//private double wheel_encoder_ticks = ticks_per_inch * wheel_diameter * Math.PI;   //original 537.6</span><span class="s1"> 
 
    </span><span class="s0">double </span><span class="s1">gs_previous_speed; 
    </span><span class="s0">double </span><span class="s1">gs_previous_ticks_traveled; 
    ElapsedTime gs_speed_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
    </span><span class="s0">boolean </span><span class="s1">gs_first_run = </span><span class="s0">true</span><span class="s1">; 
    </span><span class="s0">int </span><span class="s1">hard_stop = </span><span class="s4">5</span><span class="s1">;  </span><span class="s3">//seconds per operation i.e. move for this much or less</span><span class="s1"> 
 
    </span><span class="s0">public </span><span class="s1">DBotBase() { 
    } 
 
    </span><span class="s0">public void </span><span class="s1">markerDrop() { 
        robot.marker.setPosition(</span><span class="s4">0</span><span class="s1">); 
        sleep(</span><span class="s4">500</span><span class="s1">); 
        robot.marker.setPosition(</span><span class="s4">0.8</span><span class="s1">); 
 
    } 
 
    </span><span class="s0">public void </span><span class="s1">resetEncoders() { 
        robot.FR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); 
        robot.FL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); 
        robot.RR.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); 
        robot.RL.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER); 
 
        sleep(</span><span class="s4">100</span><span class="s1">); 
 
        robot.FR.setMode(DcMotor.RunMode.RUN_USING_ENCODER); 
        robot.FL.setMode(DcMotor.RunMode.RUN_USING_ENCODER); 
        robot.RR.setMode(DcMotor.RunMode.RUN_USING_ENCODER); 
        robot.RL.setMode(DcMotor.RunMode.RUN_USING_ENCODER); 
    } 
 
    </span><span class="s0">public void </span><span class="s1">stopRobot() { 
        robot.RL.setPower(</span><span class="s4">0.0</span><span class="s1">); 
        robot.RR.setPower(</span><span class="s4">0.0</span><span class="s1">); 
        robot.FR.setPower(</span><span class="s4">0.0</span><span class="s1">); 
        robot.FL.setPower(</span><span class="s4">0.0</span><span class="s1">); 
        robot.LL.setPower(</span><span class="s4">0.0</span><span class="s1">); 
 
        </span><span class="s3">//resetEncoders();</span><span class="s1"> 
    } 
 
    </span><span class="s0">public void </span><span class="s1">latchUp(</span><span class="s0">double </span><span class="s1">speed, </span><span class="s0">double </span><span class="s1">time) { 
        robot.LL.setPower(speed); 
        runtime.reset(); 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; (runtime.seconds() &lt;= time)) { 
            telemetry.addData(</span><span class="s2">&quot;Path&quot;</span><span class="s1">, </span><span class="s2">&quot;Leg 2: %2.5f S Elapsed&quot;</span><span class="s1">, runtime.seconds()); 
            </span><span class="s3">//  telemetry.update();</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">public void </span><span class="s1">latchDown(</span><span class="s0">double </span><span class="s1">speed, </span><span class="s0">double </span><span class="s1">time) { 
        robot.LL.setPower(-speed); 
        runtime.reset(); 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; (runtime.seconds() &lt;= time)) { 
            telemetry.addData(</span><span class="s2">&quot;Path&quot;</span><span class="s1">, </span><span class="s2">&quot;Leg 2: %2.5f S Elapsed&quot;</span><span class="s1">, runtime.seconds()); 
            </span><span class="s3">//   telemetry.update();</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s3">/* 
    public String vuforiaCapture() { 
        int cameraMonitorViewId = robot.hwMap.appContext.getResources().getIdentifier(&quot;cameraMonitorViewId&quot;, &quot;id&quot;, robot.hwMap.appContext.getPackageName()); 
        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId); 
 
        parameters.vuforiaLicenseKey = &quot;AeYAHIn/////AAAAGfVr1aFjUEHlh1uCvvWMJFtG8Y1D0YvNXpfCJTXkpgrNedm+jaqR+2trR9dGNzyeuHUMqo42P7DuJIp1IPDBDF5oepx6kw121V3vAc3sR5F43oix5brWapqdLcvFYcdFmWqg3AvIy436p1bkMhhJgcVEzXzIususTncxlVaHDDohnS9zN38qFcbFeKWH8cLG8lbt+2sNqoGJgOQ1/Oq6wEf3ceIS1x2BsguyUtkPLG0OQALkjbktRMdfLHe34ldDuCddP1ekNgkvwauoxOJqYKJKZX15h3VZfRtnp4mArn6Bxx8vWITXm690wfsdAio1LrRGm+NBovMapDxs9IKJuiH53nEoYrvat8IGG9IhMp67&quot;; 
 
        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.BACK; 
        //  Instantiate the Vuforia engine 
        vuforia = ClassFactory.getInstance().createVuforia(parameters); 
 
        // Load the data sets that for the trackable objects. These particular data 
        // sets are stored in the 'assets' part of our application. 
        VuforiaTrackables targetsRoverRuckus = this.vuforia.loadTrackablesFromAsset(&quot;RoverRuckus&quot;); 
        VuforiaTrackable blueRover = targetsRoverRuckus.get(0); 
        blueRover.setName(&quot;Blue-Rover&quot;); 
        VuforiaTrackable redFootprint = targetsRoverRuckus.get(1); 
        redFootprint.setName(&quot;Red-Footprint&quot;); 
        VuforiaTrackable frontCraters = targetsRoverRuckus.get(2); 
        frontCraters.setName(&quot;Front-Craters&quot;); 
        VuforiaTrackable backSpace = targetsRoverRuckus.get(3); 
        backSpace.setName(&quot;Back-Space&quot;); 
 
        // For convenience, gather together all the trackable objects in one easily-iterable collection 
        List&lt;VuforiaTrackable&gt; allTrackables = new ArrayList&lt;VuforiaTrackable&gt;(); 
        allTrackables.addAll(targetsRoverRuckus); 
 
        targetsRoverRuckus.activate(); 
 
        boolean targetVisible = false; 
        int i = 0; 
 
        while (!targetVisible &amp;&amp; i &lt; 5) { 
            sleep(1000); 
            for (VuforiaTrackable trackable : allTrackables) { 
                if (((VuforiaTrackableDefaultListener) trackable.getListener()).isVisible()) { 
                    telemetry.addData(&quot;Visible Target&quot;, trackable.getName()); 
                    telemetry.update(); 
                    targetVisible = true; 
                    return trackable.getName(); 
                } 
            } 
            i++; 
        } 
 
        if (!targetVisible) 
            telemetry.addData(&quot;visible target&quot;, &quot;not visible&quot;); 
 
        telemetry.update(); 
        return &quot;not visible&quot;; 
    } 
    */</span><span class="s1"> 
 
    </span><span class="s0">public void </span><span class="s1">initialize() { 
        robot.init(hardwareMap); 
        </span><span class="s3">// calibrateGyro();</span><span class="s1"> 
        Orientation angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES); 
 
        telemetry.addData(</span><span class="s2">&quot;heading&quot;</span><span class="s1">, angles.firstAngle); 
        telemetry.addData(</span><span class="s2">&quot;firstAngle&quot;</span><span class="s1">, angles.firstAngle); 
 
        </span><span class="s3">//robot.claw.setPosition(.5);</span><span class="s1"> 
        </span><span class="s3">// robot.liftMotor.setPower(ARM_UP_POWER);</span><span class="s1"> 
 
        sleep(</span><span class="s4">2000</span><span class="s1">); 
 
        </span><span class="s3">// Send telemetry message to signify robotrt waiting;</span><span class="s1"> 
        telemetry.addData(</span><span class="s2">&quot;Status&quot;</span><span class="s1">, </span><span class="s2">&quot;Ready to run&quot;</span><span class="s1">);    </span><span class="s3">//</span><span class="s1"> 
        telemetry.update(); 
 
    } 
 
    </span><span class="s0">private double </span><span class="s1">getSpeed(</span><span class="s0">double </span><span class="s1">ticks_traveled) { 
        </span><span class="s0">double </span><span class="s1">new_speed; 
 
        </span><span class="s0">if </span><span class="s1">(gs_first_run) { 
            gs_previous_ticks_traveled = ticks_traveled; 
            gs_speed_timer.reset(); 
            gs_previous_speed = </span><span class="s4">1</span><span class="s1">; 
            gs_first_run = </span><span class="s0">false</span><span class="s1">; 
        } 
 
        </span><span class="s0">if </span><span class="s1">(gs_speed_timer.seconds() &gt;= </span><span class="s4">.1</span><span class="s1">) { 
            new_speed = (ticks_traveled - gs_previous_ticks_traveled) / ticks_per_inch; 
            gs_speed_timer.reset(); 
            gs_previous_speed = new_speed; 
            gs_previous_ticks_traveled = ticks_traveled; 
        } </span><span class="s0">else </span><span class="s1">{ 
            new_speed = gs_previous_speed; 
        } 
 
        </span><span class="s0">return </span><span class="s1">new_speed; 
    } 
 
    </span><span class="s0">private double </span><span class="s1">shift_heading(</span><span class="s0">double </span><span class="s1">heading) { 
        </span><span class="s0">double </span><span class="s1">shiftvalue = </span><span class="s4">3</span><span class="s1">; 
        heading = heading + shiftvalue; 
 
        </span><span class="s0">if </span><span class="s1">(heading &gt;= </span><span class="s4">360</span><span class="s1">) { 
            heading = heading - </span><span class="s4">360</span><span class="s1">; 
        } </span><span class="s0">else if </span><span class="s1">(heading &lt; </span><span class="s4">0</span><span class="s1">) { 
            heading = heading + </span><span class="s4">360</span><span class="s1">; 
        } 
        </span><span class="s0">return </span><span class="s1">heading; 
    } 
 
    </span><span class="s0">private double </span><span class="s1">get_current_heading() { 
        orientation = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES); 
        current_heading = orientation.firstAngle; 
 
        </span><span class="s0">if </span><span class="s1">(current_heading &lt; </span><span class="s4">0</span><span class="s1">) { 
            current_heading = -current_heading; 
        } </span><span class="s0">else </span><span class="s1">{ 
            current_heading = </span><span class="s4">360 </span><span class="s1">- current_heading; 
        } 
        current_heading = shift_heading(current_heading); 
        </span><span class="s0">return </span><span class="s1">current_heading; 
    } 
 
    </span><span class="s0">public void </span><span class="s1">turn_to_heading(</span><span class="s0">double </span><span class="s1">target_heading) { 
        </span><span class="s0">boolean </span><span class="s1">go_right; 
        </span><span class="s0">double </span><span class="s1">current_heading; 
        </span><span class="s0">double </span><span class="s1">degrees_to_turn; 
        </span><span class="s0">double </span><span class="s1">wheel_power; 
        </span><span class="s0">double </span><span class="s1">prev_heading = </span><span class="s4">0</span><span class="s1">; 
        ElapsedTime timeout_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
 
        current_heading = get_current_heading(); 
        degrees_to_turn = Math.abs(target_heading - current_heading); 
 
        go_right = target_heading &gt; current_heading; 
        </span><span class="s0">if </span><span class="s1">(degrees_to_turn &gt; </span><span class="s4">180</span><span class="s1">) { 
            go_right = !go_right; 
            degrees_to_turn = </span><span class="s4">360 </span><span class="s1">- degrees_to_turn; 
        } 
 
        timeout_timer.reset(); 
        prev_heading = current_heading; 
        </span><span class="s0">while </span><span class="s1">(degrees_to_turn &gt; </span><span class="s4">.5 </span><span class="s1">&amp;&amp; opModeIsActive() &amp;&amp; timeout_timer.seconds() &lt; </span><span class="s4">2</span><span class="s1">) { 
            </span><span class="s3">//wheel_power = (2 * Math.pow((degrees_to_turn + 13) / 30, 2) + 15) / 100;</span><span class="s1"> 
            wheel_power = (</span><span class="s4">0.75 </span><span class="s1">* degrees_to_turn) / </span><span class="s4">100</span><span class="s1">; 
            </span><span class="s0">if </span><span class="s1">(go_right) { 
                wheel_power = -wheel_power; 
            } 
 
            robot.FR.setPower(wheel_power); 
            robot.RR.setPower(wheel_power); 
            robot.FL.setPower(-wheel_power); 
            robot.RL.setPower(-wheel_power); 
 
            current_heading = get_current_heading(); 
            degrees_to_turn = Math.abs(target_heading - current_heading);       </span><span class="s3">// Calculate how far is remaining to turn</span><span class="s1"> 
 
            go_right = target_heading &gt; current_heading; 
 
            </span><span class="s0">if </span><span class="s1">(degrees_to_turn &gt; </span><span class="s4">180</span><span class="s1">) { 
                go_right = !go_right; 
                degrees_to_turn = </span><span class="s4">360 </span><span class="s1">- degrees_to_turn; 
            } 
 
            </span><span class="s0">if </span><span class="s1">(Math.abs(current_heading - prev_heading) &gt; </span><span class="s4">1</span><span class="s1">) { 
                timeout_timer.reset(); 
                prev_heading = current_heading; 
            } 
        } 
        stopRobot(); 
    } </span><span class="s3">// end of turn_to_heading</span><span class="s1"> 
 
    </span><span class="s0">public void </span><span class="s1">move_forward(</span><span class="s0">double </span><span class="s1">inches_to_travel, </span><span class="s0">double </span><span class="s1">speed) { 
        </span><span class="s0">double </span><span class="s1">starting_speed = </span><span class="s4">.05</span><span class="s1">; </span><span class="s3">//starting speed</span><span class="s1"> 
        </span><span class="s0">double </span><span class="s1">current_speed = starting_speed; 
        </span><span class="s0">double </span><span class="s1">speed_adjustment; </span><span class="s3">//how much to increase or decrease by</span><span class="s1"> 
        </span><span class="s0">double </span><span class="s1">adjustment_interval = </span><span class="s4">5</span><span class="s1">;  </span><span class="s3">//increase or decrease after this interval in millisec</span><span class="s1"> 
        </span><span class="s0">double </span><span class="s1">optimal_braking = </span><span class="s4">10</span><span class="s1">; </span><span class="s3">//braking distance in inches</span><span class="s1"> 
 
        </span><span class="s0">int </span><span class="s1">ticks_to_travel; 
        </span><span class="s0">double </span><span class="s1">remaining_inches; 
 
        </span><span class="s0">boolean </span><span class="s1">destination_reached = </span><span class="s0">false</span><span class="s1">; 
        </span><span class="s0">boolean </span><span class="s1">going_backwards = </span><span class="s0">false</span><span class="s1">; 
 
        </span><span class="s0">int </span><span class="s1">start_position_FL; 
        </span><span class="s0">int </span><span class="s1">start_position_RL; 
        </span><span class="s0">int </span><span class="s1">start_position_FR; 
        </span><span class="s0">int </span><span class="s1">start_position_RR; 
 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RR; 
 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled_l = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled_r = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s3">//this is when we should be done</span><span class="s1"> 
        ElapsedTime timeout_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
        </span><span class="s3">//this is when we adjust speed</span><span class="s1"> 
        ElapsedTime adjustment_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(ElapsedTime.Resolution.MILLISECONDS); 
 
        </span><span class="s3">//check if robot needs to go forward (+ve speed) or backward (-ve speed passed)</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(speed &lt; </span><span class="s4">0</span><span class="s1">) { 
            going_backwards = </span><span class="s0">true</span><span class="s1">;                 </span><span class="s3">//the bot needs to go backwards</span><span class="s1"> 
            current_speed = -current_speed;        </span><span class="s3">//starting speed will be -ve</span><span class="s1"> 
            </span><span class="s3">//speed_adjustment = -speed_adjustment;  //speed ramp up will be -ve as well</span><span class="s1"> 
        } 
 
        </span><span class="s3">//calculate initial ticks to travel</span><span class="s1"> 
        ticks_to_travel = (</span><span class="s0">int</span><span class="s1">) (inches_to_travel * ticks_per_inch); 
 
        </span><span class="s3">//reset encoders before beginning</span><span class="s1"> 
        resetEncoders(); 
 
        </span><span class="s3">//get initial encoder values for all 4 wheels</span><span class="s1"> 
        start_position_FL = robot.FL.getCurrentPosition(); 
        start_position_RL = robot.RL.getCurrentPosition(); 
        start_position_FR = robot.FR.getCurrentPosition(); 
        start_position_RR = robot.RR.getCurrentPosition(); 
 
        timeout_timer.reset(); 
        adjustment_timer.reset(); 
 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; !destination_reached &amp;&amp; timeout_timer.seconds() &lt; hard_stop) { 
            telemetry.addData(</span><span class="s2">&quot;Speed is&quot;</span><span class="s1">, current_speed); 
            telemetry.update(); 
 
            robot.FR.setPower(current_speed); 
            robot.RR.setPower(current_speed); 
            robot.FL.setPower(current_speed); 
            robot.RL.setPower(current_speed); 
 
            ticks_traveled_FL = Math.abs(robot.FL.getCurrentPosition() - start_position_FL); 
            ticks_traveled_RL = Math.abs(robot.RL.getCurrentPosition() - start_position_RL); 
            ticks_traveled_FR = Math.abs(robot.FR.getCurrentPosition() - start_position_FR); 
            ticks_traveled_RR = Math.abs(robot.RR.getCurrentPosition() - start_position_RR); 
 
            </span><span class="s3">// of the 4 wheels, determines lowest ticks traveled</span><span class="s1"> 
            lowest_ticks_traveled_l = Math.min(ticks_traveled_FL, ticks_traveled_RL); 
            lowest_ticks_traveled_r = Math.min(ticks_traveled_FR, ticks_traveled_RR); 
            lowest_ticks_traveled = Math.min(lowest_ticks_traveled_l, lowest_ticks_traveled_r); 
 
            remaining_inches = inches_to_travel - ((</span><span class="s0">double</span><span class="s1">) lowest_ticks_traveled / ticks_per_inch); 
            destination_reached = (lowest_ticks_traveled &gt;= ticks_to_travel); 
 
            </span><span class="s3">//ramp up or ramp down only when adjustment interval is reached i.e. every 10 millisec</span><span class="s1"> 
            </span><span class="s3">//if (adjustment_timer.time() &gt; adjustment_interval) {</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(remaining_inches &gt;= optimal_braking) { 
                </span><span class="s3">//adjust only if its not the speed passed to the method</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">(Math.abs(current_speed) &lt; Math.abs(speed)) { 
                    </span><span class="s3">//increase the speed</span><span class="s1"> 
                    speed_adjustment = </span><span class="s4">0.01</span><span class="s1">; </span><span class="s3">//remaining_inches / (inches_to_travel * 100);</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">(going_backwards) 
                        speed_adjustment = -speed_adjustment; 
 
                    current_speed += speed_adjustment; 
 
                    adjustment_timer.reset(); 
                } </span><span class="s0">else </span><span class="s1">{ 
                       </span><span class="s3">/* telemetry.addData(&quot;current speed is&quot;,current_speed); 
                        telemetry.addData(&quot;remaining inches is&quot;,remaining_inches); 
                        telemetry.update();*/</span><span class="s1"> 
                } 
            } </span><span class="s0">else </span><span class="s1">{ </span><span class="s3">//start ramping down</span><span class="s1"> 
                </span><span class="s0">if </span><span class="s1">(Math.abs(current_speed) &gt; Math.abs(starting_speed)) { 
                    </span><span class="s3">//decrease the speed</span><span class="s1"> 
                    speed_adjustment = </span><span class="s4">0.025</span><span class="s1">; </span><span class="s3">//remaining_inches / (inches_to_travel * 100);</span><span class="s1"> 
                    </span><span class="s0">if </span><span class="s1">(going_backwards) 
                        speed_adjustment = -speed_adjustment; 
 
                    current_speed -= speed_adjustment; 
 
                    adjustment_timer.reset(); 
                        </span><span class="s3">/*telemetry.addData(&quot;current speed is&quot;,current_speed); 
                        telemetry.addData(&quot;remaining inches is&quot;,remaining_inches); 
                        telemetry.update();*/</span><span class="s1"> 
                } </span><span class="s0">else </span><span class="s1">{ 
                        </span><span class="s3">/*telemetry.addData(&quot;else current speed is&quot;,current_speed); 
                        telemetry.addData(&quot;else remaining inches is&quot;,remaining_inches); 
                        telemetry.update();*/</span><span class="s1"> 
                } 
            } 
            </span><span class="s3">//}</span><span class="s1"> 
            </span><span class="s3">/* 
            //ramp up or ramp down only when adjustment interval is reached i.e. every 10 millisec 
            if (adjustment_timer.time() &gt; adjustment_interval) { 
                //adjust only if its not the speed passed to the method 
                if (remaining_inches &gt;= optimal_braking) { 
                    if (Math.abs(current_speed) &lt; Math.abs(speed)) { 
                        //increase the speed 
                        current_speed += speed_adjustment; 
 
                        adjustment_timer.reset(); 
                    } 
                } 
                else { //start ramping down 
                    if (Math.abs(current_speed) &gt; Math.abs(starting_speed * 2)) { 
                        //decrease the speed 
                        current_speed -= speed_adjustment; 
 
                        adjustment_timer.reset(); 
                    } 
                } 
                */</span><span class="s1"> 
 
 
        } 
 
        stopRobot(); 
      </span><span class="s3">/*  telemetry.addData(&quot;FL&quot;,robot.FL.getCurrentPosition()); 
        telemetry.addData(&quot;FR&quot;,robot.FR.getCurrentPosition()); 
        telemetry.addData(&quot;RL&quot;,robot.RL.getCurrentPosition()); 
        telemetry.addData(&quot;RR&quot;,robot.RR.getCurrentPosition()); 
        telemetry.update(); 
        */</span><span class="s1"> 
        sleep(</span><span class="s4">5000</span><span class="s1">); 
 
    } </span><span class="s3">// end of go_forward</span><span class="s1"> 
 
    </span><span class="s0">public void </span><span class="s1">move_forwardTime(</span><span class="s0">double </span><span class="s1">inches_to_travel, </span><span class="s0">double </span><span class="s1">speed) { 
        ElapsedTime log_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
 
        </span><span class="s0">double </span><span class="s1">current_speed = </span><span class="s4">.05</span><span class="s1">; 
        </span><span class="s0">double </span><span class="s1">speed_increase = </span><span class="s4">.05</span><span class="s1">; 
        </span><span class="s0">double </span><span class="s1">actual_speed; 
 
        </span><span class="s0">int </span><span class="s1">ticks_to_travel; 
        </span><span class="s0">double </span><span class="s1">remaining_inches; 
 
        </span><span class="s0">boolean </span><span class="s1">destination_reached = </span><span class="s0">false</span><span class="s1">; 
        </span><span class="s0">boolean </span><span class="s1">going_backwards = </span><span class="s0">false</span><span class="s1">; 
        </span><span class="s0">int </span><span class="s1">start_position_FL; 
        </span><span class="s0">int </span><span class="s1">start_position_RL; 
        </span><span class="s0">int </span><span class="s1">start_position_FR; 
        </span><span class="s0">int </span><span class="s1">start_position_RR; 
        </span><span class="s0">int </span><span class="s1">previous_ticks_traveled_L = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RR; 
 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled_l = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled_r = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">int </span><span class="s1">lowest_ticks_traveled = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s0">double </span><span class="s1">previous_log_timer = </span><span class="s4">0</span><span class="s1">; 
 
        ElapsedTime timeout_timer = </span><span class="s0">new </span><span class="s1">ElapsedTime(); 
 
        </span><span class="s0">if </span><span class="s1">(speed &lt; </span><span class="s4">0</span><span class="s1">) { 
            going_backwards = </span><span class="s0">true</span><span class="s1">; 
            speed_increase = -speed_increase; 
            current_speed = -current_speed; 
        } 
 
        </span><span class="s3">//inches_to_travel = inches_to_travel - lagreduction;</span><span class="s1"> 
        ticks_to_travel = (</span><span class="s0">int</span><span class="s1">) (inches_to_travel * ticks_per_inch); 
 
        </span><span class="s3">//resetencoders</span><span class="s1"> 
        resetEncoders(); 
 
        start_position_FL = robot.FL.getCurrentPosition(); 
        start_position_RL = robot.RL.getCurrentPosition(); 
        start_position_FR = robot.FR.getCurrentPosition(); 
        start_position_RR = robot.RR.getCurrentPosition(); 
 
        log_timer.reset(); 
        timeout_timer.reset(); 
 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; !destination_reached &amp;&amp; timeout_timer.seconds() &lt; </span><span class="s4">1</span><span class="s1">) { 
 
            current_speed = current_speed + speed_increase;  </span><span class="s3">// this is to slowly ramp up the speed so we don't slip</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(Math.abs(current_speed) &gt; Math.abs(speed)) { 
                current_speed = speed; 
            } 
 
            robot.FR.setPower(current_speed); 
            robot.RR.setPower(current_speed); 
            robot.FL.setPower(current_speed); 
            robot.RL.setPower(current_speed); 
 
            ticks_traveled_FL = Math.abs(robot.FL.getCurrentPosition() - start_position_FL); 
            ticks_traveled_RL = Math.abs(robot.RL.getCurrentPosition() - start_position_RL); 
            ticks_traveled_FR = Math.abs(robot.FR.getCurrentPosition() - start_position_FR); 
            ticks_traveled_RR = Math.abs(robot.RR.getCurrentPosition() - start_position_RR); 
 
            </span><span class="s3">// of the 4 wheels, determines lowest ticks traveled</span><span class="s1"> 
            lowest_ticks_traveled_l = Math.min(ticks_traveled_FL, ticks_traveled_RL); 
            lowest_ticks_traveled_r = Math.min(ticks_traveled_FR, ticks_traveled_RR); 
            lowest_ticks_traveled = Math.min(lowest_ticks_traveled_l, lowest_ticks_traveled_r); 
 
            actual_speed = getSpeed(lowest_ticks_traveled); 
 
            </span><span class="s3">//if (actual_speed &gt; 0.2) {  // if we're going less than this we aren't moving.</span><span class="s1"> 
            </span><span class="s3">//    timeout_timer.reset();</span><span class="s1"> 
            </span><span class="s3">//}</span><span class="s1"> 
 
            </span><span class="s0">if </span><span class="s1">(lowest_ticks_traveled_l != previous_ticks_traveled_L &amp;&amp; log_timer.seconds() - previous_log_timer &gt; </span><span class="s4">.1</span><span class="s1">) { 
                previous_log_timer = log_timer.seconds(); 
                previous_ticks_traveled_L = lowest_ticks_traveled_l; 
            } 
 
            destination_reached = (lowest_ticks_traveled &gt;= ticks_to_travel); 
            remaining_inches = inches_to_travel - ((</span><span class="s0">double</span><span class="s1">) lowest_ticks_traveled / ticks_per_inch); 
 
            </span><span class="s0">if </span><span class="s1">(remaining_inches &lt;= actual_speed &amp;&amp; Math.abs(speed) &gt; </span><span class="s4">.2</span><span class="s1">) { 
                speed = </span><span class="s4">.2</span><span class="s1">; 
                </span><span class="s0">if </span><span class="s1">(going_backwards) { 
                    speed = -speed; 
                } 
            } 
        } 
        stopRobot(); 
        telemetry.addData(</span><span class="s2">&quot;FL&quot;</span><span class="s1">, robot.FL.getCurrentPosition()); 
        telemetry.addData(</span><span class="s2">&quot;FR&quot;</span><span class="s1">, robot.FR.getCurrentPosition()); 
        telemetry.addData(</span><span class="s2">&quot;RL&quot;</span><span class="s1">, robot.RL.getCurrentPosition()); 
        telemetry.addData(</span><span class="s2">&quot;RR&quot;</span><span class="s1">, robot.RR.getCurrentPosition()); 
        telemetry.update(); 
        sleep(</span><span class="s4">5000</span><span class="s1">); 
 
    } </span><span class="s3">// end of go_forward</span><span class="s1"> 
 
    </span><span class="s0">public double </span><span class="s1">move_sideways(</span><span class="s0">double </span><span class="s1">heading, </span><span class="s0">double </span><span class="s1">speed, </span><span class="s0">double </span><span class="s1">inches) { 
        </span><span class="s0">double </span><span class="s1">angleradians; 
 
        </span><span class="s0">double </span><span class="s1">leftfrontpower; 
        </span><span class="s0">double </span><span class="s1">rightfrontpower; 
        </span><span class="s0">double </span><span class="s1">leftrearpower; 
        </span><span class="s0">double </span><span class="s1">rightrearpower; 
        </span><span class="s0">double </span><span class="s1">turningpower = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s0">boolean </span><span class="s1">destinationreached = </span><span class="s0">false</span><span class="s1">; 
 
        </span><span class="s0">int </span><span class="s1">ticks_to_travel; 
        </span><span class="s0">int </span><span class="s1">start_position_FL; 
        </span><span class="s0">int </span><span class="s1">start_position_RL; 
        </span><span class="s0">int </span><span class="s1">start_position_FR; 
        </span><span class="s0">int </span><span class="s1">start_position_RR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RR; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled_l; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled_r; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s3">//resetencoders</span><span class="s1"> 
        resetEncoders(); 
 
        start_position_FL = robot.FL.getCurrentPosition(); 
        start_position_RL = robot.RL.getCurrentPosition(); 
        start_position_FR = robot.FR.getCurrentPosition(); 
        start_position_RR = robot.RR.getCurrentPosition(); 
 
        ticks_to_travel = (</span><span class="s0">int</span><span class="s1">) (inches * ticks_per_inch); 
 
        </span><span class="s3">// For the cos and sin calculations below in the mecanum power calcs, angleradians = 0 is straight to the right and 180 is straight to the left.</span><span class="s1"> 
        </span><span class="s3">// Negative numbers up to -180 are backward.  Postive numbers up to 180 are forward.</span><span class="s1"> 
        </span><span class="s3">// We subtract 90 from it then convert degrees to radians because *our* robot code thinks of 0 degrees as forward, 90 as right, 180 as backward, 270 as left.</span><span class="s1"> 
 
        </span><span class="s3">// This converts from *our* degrees to radians used by the mecanum power calcs.</span><span class="s1"> 
        </span><span class="s3">// Upper left quadrant (degrees &gt; 270) is special because in that quadrant as our degrees goes up, radians goes down.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(heading &lt; </span><span class="s4">270</span><span class="s1">) { 
            angleradians = ((heading - </span><span class="s4">90</span><span class="s1">) * -</span><span class="s4">1</span><span class="s1">) * Math.PI / </span><span class="s4">180</span><span class="s1">; 
        } </span><span class="s0">else </span><span class="s1">{ 
            angleradians = (</span><span class="s4">450 </span><span class="s1">- heading) * Math.PI / </span><span class="s4">180</span><span class="s1">; 
        } 
 
        angleradians = angleradians - Math.PI / </span><span class="s4">4</span><span class="s1">; </span><span class="s3">//adjust by 45 degrees for the mecanum wheel calculations below</span><span class="s1"> 
 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; !destinationreached) { 
 
            ticks_traveled_FL = Math.abs(robot.FL.getCurrentPosition() - start_position_FL); 
            ticks_traveled_RL = Math.abs(robot.RL.getCurrentPosition() - start_position_RL); 
            ticks_traveled_FR = Math.abs(robot.FR.getCurrentPosition() - start_position_FR); 
            ticks_traveled_RR = Math.abs(robot.RR.getCurrentPosition() - start_position_RR); 
 
            </span><span class="s3">// of the 4 wheels, determines highest ticks traveled</span><span class="s1"> 
            highest_ticks_traveled_l = Math.max(ticks_traveled_FL, ticks_traveled_RL); 
            highest_ticks_traveled_r = Math.max(ticks_traveled_FR, ticks_traveled_RR); 
            highest_ticks_traveled = Math.max(highest_ticks_traveled_l, highest_ticks_traveled_r); 
 
 
            </span><span class="s0">if </span><span class="s1">(highest_ticks_traveled &gt;= ticks_to_travel) { 
                destinationreached = </span><span class="s0">true</span><span class="s1">; 
            } 
 
            leftfrontpower = speed * Math.cos(angleradians); 
            rightfrontpower = speed * Math.sin(angleradians); 
            leftrearpower = speed * Math.sin(angleradians); 
            rightrearpower = speed * Math.cos(angleradians); 
 
            robot.FL.setPower(leftfrontpower); 
            robot.FR.setPower(rightfrontpower); 
            robot.RL.setPower(leftrearpower); 
            robot.RR.setPower(rightrearpower); 
        } 
 
        stopRobot(); 
        sleep(</span><span class="s4">50</span><span class="s1">); 
 
        </span><span class="s0">return </span><span class="s1">highest_ticks_traveled / ticks_per_inch; 
    } 
 
    </span><span class="s0">public double </span><span class="s1">move_sideways_by_range(</span><span class="s0">double </span><span class="s1">heading, </span><span class="s0">double </span><span class="s1">speed, </span><span class="s0">double </span><span class="s1">inches_from_wall) { 
        </span><span class="s0">double </span><span class="s1">angleradians; 
 
        </span><span class="s0">double </span><span class="s1">leftfrontpower; 
        </span><span class="s0">double </span><span class="s1">rightfrontpower; 
        </span><span class="s0">double </span><span class="s1">leftrearpower; 
        </span><span class="s0">double </span><span class="s1">rightrearpower; 
        </span><span class="s0">double </span><span class="s1">turningpower = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">double </span><span class="s1">inches = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s0">boolean </span><span class="s1">destinationreached = </span><span class="s0">false</span><span class="s1">; 
 
        </span><span class="s0">int </span><span class="s1">ticks_to_travel; 
        </span><span class="s0">int </span><span class="s1">start_position_FL; 
        </span><span class="s0">int </span><span class="s1">start_position_RL; 
        </span><span class="s0">int </span><span class="s1">start_position_FR; 
        </span><span class="s0">int </span><span class="s1">start_position_RR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RL; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_FR; 
        </span><span class="s0">int </span><span class="s1">ticks_traveled_RR; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled_l; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled_r; 
        </span><span class="s0">int </span><span class="s1">highest_ticks_traveled = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s3">//resetencoders</span><span class="s1"> 
        resetEncoders(); 
 
        start_position_FL = robot.FL.getCurrentPosition(); 
        start_position_RL = robot.RL.getCurrentPosition(); 
        start_position_FR = robot.FR.getCurrentPosition(); 
        start_position_RR = robot.RR.getCurrentPosition(); 
 
        </span><span class="s3">//convert inches from wall to inches</span><span class="s1"> 
        </span><span class="s3">//inches = get_right_distance() - inches_from_wall;</span><span class="s1"> 
        </span><span class="s3">//ticks_to_travel = (int) (inches * ticks_per_inch);</span><span class="s1"> 
 
        </span><span class="s3">// For the cos and sin calculations below in the mecanum power calcs, angleradians = 0 is straight to the right and 180 is straight to the left.</span><span class="s1"> 
        </span><span class="s3">// Negative numbers up to -180 are backward.  Postive numbers up to 180 are forward.</span><span class="s1"> 
        </span><span class="s3">// We subtract 90 from it then convert degrees to radians because *our* robot code thinks of 0 degrees as forward, 90 as right, 180 as backward, 270 as left.</span><span class="s1"> 
 
        </span><span class="s3">// This converts from *our* degrees to radians used by the mecanum power calcs.</span><span class="s1"> 
        </span><span class="s3">// Upper left quadrant (degrees &gt; 270) is special because in that quadrant as our degrees goes up, radians goes down.</span><span class="s1"> 
        </span><span class="s0">if </span><span class="s1">(heading &lt; </span><span class="s4">270</span><span class="s1">) { 
            angleradians = ((heading - </span><span class="s4">90</span><span class="s1">) * -</span><span class="s4">1</span><span class="s1">) * Math.PI / </span><span class="s4">180</span><span class="s1">; 
        } </span><span class="s0">else </span><span class="s1">{ 
            angleradians = (</span><span class="s4">450 </span><span class="s1">- heading) * Math.PI / </span><span class="s4">180</span><span class="s1">; 
        } 
 
        angleradians = angleradians - Math.PI / </span><span class="s4">4</span><span class="s1">; </span><span class="s3">//adjust by 45 degrees for the mecanum wheel calculations below</span><span class="s1"> 
 
        </span><span class="s0">boolean </span><span class="s1">moveLeftFlag = </span><span class="s0">false</span><span class="s1">; 
        </span><span class="s0">if </span><span class="s1">(get_right_distance() &lt;= inches_from_wall) { 
            moveLeftFlag = </span><span class="s0">true</span><span class="s1">; 
        } 
 
        </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; !destinationreached) { 
            </span><span class="s3">//convert inches from wall to inches</span><span class="s1"> 
            </span><span class="s0">if </span><span class="s1">(moveLeftFlag) { 
                inches = inches_from_wall - get_right_distance(); 
            } </span><span class="s0">else</span><span class="s1"> 
                inches = get_right_distance() - inches_from_wall; 
 
 
            </span><span class="s0">if </span><span class="s1">(!moveLeftFlag &amp;&amp; inches &lt;= inches_from_wall) { 
                destinationreached = </span><span class="s0">true</span><span class="s1">; 
            } </span><span class="s0">else if </span><span class="s1">(moveLeftFlag &amp;&amp; inches &lt;= </span><span class="s4">0</span><span class="s1">) { 
                destinationreached = </span><span class="s0">true</span><span class="s1">; 
            } 
 
            telemetry.addData(</span><span class="s2">&quot;Inches to travel&quot;</span><span class="s1">, inches); 
            telemetry.addData(</span><span class="s2">&quot;destination reached&quot;</span><span class="s1">, destinationreached); 
 
            telemetry.update(); 
 
            leftfrontpower = speed * Math.cos(angleradians); 
            rightfrontpower = speed * Math.sin(angleradians); 
            leftrearpower = speed * Math.sin(angleradians); 
            rightrearpower = speed * Math.cos(angleradians); 
 
            robot.FL.setPower(leftfrontpower); 
            robot.FR.setPower(rightfrontpower); 
            robot.RL.setPower(leftrearpower); 
            robot.RR.setPower(rightrearpower); 
        } 
 
        stopRobot(); 
        sleep(</span><span class="s4">50</span><span class="s1">); 
 
        </span><span class="s0">return </span><span class="s1">highest_ticks_traveled / ticks_per_inch; 
    } 
 
    </span><span class="s0">private double </span><span class="s1">go_straight_adjustment(</span><span class="s0">double </span><span class="s1">target_heading) { 
 
        </span><span class="s3">//  This function outputs power_adjustment that should be added to right wheel and subtracted from left wheel</span><span class="s1"> 
        </span><span class="s0">double </span><span class="s1">gs_adjustment; 
        </span><span class="s0">double </span><span class="s1">current_heading; 
        </span><span class="s0">double </span><span class="s1">degrees_off; 
        </span><span class="s0">boolean </span><span class="s1">go_right; 
 
        current_heading = get_current_heading(); 
 
        go_right = target_heading &gt; current_heading; 
        degrees_off = Math.abs(target_heading - current_heading); 
 
        </span><span class="s0">if </span><span class="s1">(degrees_off &gt; </span><span class="s4">180</span><span class="s1">) { 
            go_right = !go_right; 
            degrees_off = </span><span class="s4">360 </span><span class="s1">- degrees_off; 
        } 
 
        </span><span class="s0">if </span><span class="s1">(degrees_off &lt; </span><span class="s4">.3</span><span class="s1">) { 
            gs_adjustment = </span><span class="s4">0</span><span class="s1">; 
        } </span><span class="s0">else </span><span class="s1">{ 
            gs_adjustment = (Math.pow((degrees_off + </span><span class="s4">2</span><span class="s1">) / </span><span class="s4">5</span><span class="s1">, </span><span class="s4">2</span><span class="s1">) + </span><span class="s4">2</span><span class="s1">) / </span><span class="s4">100</span><span class="s1">; 
        } 
 
        </span><span class="s0">if </span><span class="s1">(go_right) { 
            gs_adjustment = -gs_adjustment; 
        } 
 
        </span><span class="s0">return </span><span class="s1">gs_adjustment; 
 
    } </span><span class="s3">// end of go_straight_adjustment</span><span class="s1"> 
 
    </span><span class="s0">public double </span><span class="s1">get_right_distance() { 
        </span><span class="s0">return </span><span class="s1">robot.rightSensor.getDistance(DistanceUnit.INCH); 
    } 
 
 
    </span><span class="s0">public </span><span class="s1">String getGoldPositionHardCode(){ 
        </span><span class="s0">return </span><span class="s2">&quot;Right&quot;</span><span class="s1">; 
    } 
    </span><span class="s0">public </span><span class="s1">String getGoldPosition() { 
        String pos = </span><span class="s2">&quot;Error&quot;</span><span class="s1">; 
 
        </span><span class="s0">try </span><span class="s1">{ 
 
</span><span class="s3">//            initVuforia();</span><span class="s1"> 
</span><span class="s3">//            if (ClassFactory.getInstance().canCreateTFObjectDetector()) {</span><span class="s1"> 
</span><span class="s3">//                initTfod();</span><span class="s1"> 
</span><span class="s3">//            } else {</span><span class="s1"> 
</span><span class="s3">//                telemetry.addData(&quot;Sorry!&quot;, &quot;This device is not compatible with TFOD&quot;);</span><span class="s1"> 
</span><span class="s3">//                telemetry.update();</span><span class="s1"> 
</span><span class="s3">//            }</span><span class="s1"> 
 
</span><span class="s3">//            if (tfod != null) {</span><span class="s1"> 
</span><span class="s3">//                tfod.activate();</span><span class="s1"> 
</span><span class="s3">//            }</span><span class="s1"> 
 
            ElapsedTime goldTimer = </span><span class="s0">new </span><span class="s1">ElapsedTime(ElapsedTime.Resolution.MILLISECONDS); 
            goldTimer.reset(); 
 
            </span><span class="s0">while </span><span class="s1">(opModeIsActive() &amp;&amp; pos == </span><span class="s2">&quot;Error&quot; </span><span class="s1">&amp;&amp; goldTimer.time() &lt; </span><span class="s4">3000</span><span class="s1">) { 
               </span><span class="s0">if </span><span class="s1">(tfod != </span><span class="s0">null</span><span class="s1">) { 
                    </span><span class="s3">// getUpdatedRecognitions() will return null if no new information is available since</span><span class="s1"> 
                    </span><span class="s3">// the last time that call was made.</span><span class="s1"> 
                    List&lt;Recognition&gt; updatedRecognitions = tfod.getUpdatedRecognitions(); 
                    </span><span class="s0">if </span><span class="s1">(updatedRecognitions != </span><span class="s0">null</span><span class="s1">) { 
                        telemetry.addData(</span><span class="s2">&quot;# Object Detected&quot;</span><span class="s1">, updatedRecognitions.size()); 
                        </span><span class="s0">if </span><span class="s1">(updatedRecognitions.size() == </span><span class="s4">3</span><span class="s1">) { 
                            </span><span class="s0">int </span><span class="s1">goldMineralX = -</span><span class="s4">1</span><span class="s1">; 
                            </span><span class="s0">int </span><span class="s1">silverMineral1X = -</span><span class="s4">1</span><span class="s1">; 
                            </span><span class="s0">int </span><span class="s1">silverMineral2X = -</span><span class="s4">1</span><span class="s1">; 
                            </span><span class="s0">for </span><span class="s1">(Recognition recognition : updatedRecognitions) { 
                                </span><span class="s0">if </span><span class="s1">(recognition.getLabel().equals(LABEL_GOLD_MINERAL)) { 
                                    goldMineralX = (</span><span class="s0">int</span><span class="s1">) recognition.getLeft(); 
                                } </span><span class="s0">else if </span><span class="s1">(silverMineral1X == -</span><span class="s4">1</span><span class="s1">) { 
                                    silverMineral1X = (</span><span class="s0">int</span><span class="s1">) recognition.getLeft(); 
                                } </span><span class="s0">else </span><span class="s1">{ 
                                    silverMineral2X = (</span><span class="s0">int</span><span class="s1">) recognition.getLeft(); 
                                } 
                            } 
                            </span><span class="s0">if </span><span class="s1">(goldMineralX != -</span><span class="s4">1 </span><span class="s1">&amp;&amp; silverMineral1X != -</span><span class="s4">1 </span><span class="s1">&amp;&amp; silverMineral2X != -</span><span class="s4">1</span><span class="s1">) { 
                                </span><span class="s0">if </span><span class="s1">(goldMineralX &lt; silverMineral1X &amp;&amp; goldMineralX &lt; silverMineral2X) { 
                                    pos = </span><span class="s2">&quot;Left&quot;</span><span class="s1">; 
                                } </span><span class="s0">else if </span><span class="s1">(goldMineralX &gt; silverMineral1X &amp;&amp; goldMineralX &gt; silverMineral2X) { 
                                    pos = </span><span class="s2">&quot;Right&quot;</span><span class="s1">; 
                                } </span><span class="s0">else </span><span class="s1">{ 
                                    pos = </span><span class="s2">&quot;Center&quot;</span><span class="s1">; 
                                } 
                            } 
                        } 
                        telemetry.update(); 
                    } 
                } 
            } 
        } 
        </span><span class="s0">catch </span><span class="s1">(Exception ex) { 
            pos = </span><span class="s2">&quot;Error&quot;</span><span class="s1">; 
            telemetry.addData(</span><span class="s2">&quot;Don't know Gold Mineral Position&quot;</span><span class="s1">, </span><span class="s2">&quot;Error&quot;</span><span class="s1">); 
        } 
        </span><span class="s0">finally </span><span class="s1">{ 
            </span><span class="s0">if </span><span class="s1">(tfod != </span><span class="s0">null</span><span class="s1">) { 
                tfod.shutdown(); 
                vuforia = </span><span class="s0">null</span><span class="s1">; 
            } 
        } 
        telemetry.addData(</span><span class="s2">&quot;Gold Mineral Position&quot;</span><span class="s1">, pos); 
        telemetry.update(); 
        </span><span class="s0">return </span><span class="s1">pos; 
    } 
 
    </span><span class="s3">/** 
     * Initialize the Vuforia localization engine. 
     */</span><span class="s1"> 
    </span><span class="s0">public void </span><span class="s1">initVuforia() { 
        </span><span class="s3">/* 
         * Configure Vuforia by creating a Parameter object, and passing it to the Vuforia engine. 
         */</span><span class="s1"> 
        VuforiaLocalizer.Parameters parameters = </span><span class="s0">new </span><span class="s1">VuforiaLocalizer.Parameters(); 
 
        parameters.vuforiaLicenseKey = VUFORIA_KEY; 
        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.FRONT; 
 
        </span><span class="s3">//  Instantiate the Vuforia engine</span><span class="s1"> 
        vuforia = ClassFactory.getInstance().createVuforia(parameters); 
 
        </span><span class="s3">// Loading trackables is not necessary for the Tensor Flow Object Detection engine.</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Initialize the Tensor Flow Object Detection engine. 
     */</span><span class="s1"> 
    </span><span class="s0">public void </span><span class="s1">initTfod() { 
        </span><span class="s0">int </span><span class="s1">tfodMonitorViewId = hardwareMap.appContext.getResources().getIdentifier( 
                </span><span class="s2">&quot;tfodMonitorViewId&quot;</span><span class="s1">, </span><span class="s2">&quot;id&quot;</span><span class="s1">, hardwareMap.appContext.getPackageName()); 
        TFObjectDetector.Parameters tfodParameters = </span><span class="s0">new </span><span class="s1">TFObjectDetector.Parameters(tfodMonitorViewId); 
        tfod = ClassFactory.getInstance().createTFObjectDetector(tfodParameters, vuforia); 
        tfod.loadModelFromAsset(TFOD_MODEL_ASSET, LABEL_GOLD_MINERAL, LABEL_SILVER_MINERAL); 
 
        </span><span class="s0">if </span><span class="s1">(tfod != </span><span class="s0">null</span><span class="s1">) { 
            tfod.activate(); 
        } 
 
    } 
 
} 
</span></pre>
</body>
</html>